##Initial simulations of Daphnia populaiton for plastic stuff 

library(tidyverse)
library(deSolve)
library(GillespieSSA)
library(ecotoxicology)
library(BiocManager)
library(drc)
library(sandwich)
library(lmtest)
library(multcomp)
library(cowplot)
library(MASS)
library(devtools)

############################### Analysis Plan

#Step 1: Get LC/EC50s done and then try and make that into day by day estimates ***DONE
#Step 2: Get natural birth/mortality rates
#Step 3: Build the original growth model ***DONE
#Step 4: Discretize the dose response curves to 100 different values, and make the 
#concentration values are the same for both ***DONE
#Step 5a: Loop the simulation for 100 times, doing it at each of the 100 values for concentration ***DONE
#Step 5b: This will result in a matrix at each of the 100 concentrations for each time point,
#take this matrix, and plot the results at 0, 50 and 100 pollution levels ***DONE
#Step 6: then run at 0, 50, and 100 with stochasticity, and run each of those for 10,000 times
#Step 7: Run this again with different carrying capacities
#Step 8: Then make a heat map, using an empty matrix to start, then  using nested loops to show how the 
#two main variables we're using interact
#Step 9: Try to run the simulations over a timespan but allow for the concentration of plastic to increase
#as we expect it to over that time period 


####### Growth Function

# determine birth and death rates
## since b and d are per capita rates, that's what we want to calculate
# birth first
total_pop_b <- (120+116+125+114+113+115+114+120+128+118+119+120+118) #all replicates for the control group from besseling
total_births <- (61+61+66+60+61+62++61+64+66+63+62+61+59)
pcbr <- total_births/total_pop_b

#now deaths - since there was no effect of mortality at ALL, 
#we use all the values from their study
total_pop_d <- (16+12*11)
total_deaths <- (3+2+1+3+3+2+6+0+12+2+0+2)
pcdr <- total_deaths/total_pop_d
pcdr <- 0.013 #this info comes from Leila so cite Kirk et al. (In Prep)

daphgrow <- function(t, state, parameters) {
  #this will calculate the population growth rate
  
  N <- state
  b <- parameters[1]
  phi <- parameters[2]
  k <- parameters[3]
  u <- parameters[4]
  alpha <- parameters[5]
  
  dN = (b-phi)*N*(1-(N/k)) - (u+alpha)*N
  
  return(list(c(dN)))
}

####### Calculate LC50 and EC50 values

#make data for both the reproduction one (KIM) and the bees one 
concentrationKIM <- c(1,5,10,20,30,40,60,80) #first row is concentration (mg/L)
exposureKIM <- c(40,40,40,40,40,40,40,40) #second row is number of exposed
mortalityKIM <- c(0,0,0,0.125,0.075,0.45,0.625,0.9)#third row is number of dead
responseBES1 <- c(62.07692308,56.4,61.54545455,64.66666667,56.44444444,60.2,57.5,60.83333333,45.4,42.25,49.6)
responseBES2 <- c((pcbr - (53/(118.4615))),(pcbr - (59/(118.4615))),(pcbr - (62/(118.4615))),
                  (pcbr - (56/(1+16+16+25+25+31))),(pcbr - (60/(1+9+25+27+29+31))),(pcbr - (58/(118.4615))),
                  (pcbr - (61/(118.4615))),(pcbr - (59/(118.4615))),(pcbr - (42/(118.4615))),(pcbr - (46/(118.4615))))
 #reduction in neonate number
concentrationBES <- c(0.22,0.44,0.88,1.8,3.5,7.0,14,32,70,150) #  nano-PS concentration (mg/L), first one is the blank
BESdata <- data.frame(cbind(responseBES,concentrationBES))

#EC50 calculation for number of neonates
EC501 <- drm(responseBES2~ concentrationBES, fct = LL.4()) #using the LL.4 one which is four parameter Log-logistic function with ED50 as parameter and a lower limit at 0
summary(EC501)

############################################ Concentration calculations

## So now the challenge is to come up with realistic concentrations in the environment. 
# From Besseling: plastic was: polystyrene naoparticle stocks were supplied as 20% nano-PoS dispersion by AVT-PCC, 70nm
# According to ThermoFisher Scientific, the same size polystyrene nanospheres have density of 1.05 g/cm^3
# volume of a sphere: 4/3*pi*r^3
# mass = density * volume
# so the mass of one sphere is the density * the volume which we can calculate from the diameter
# do those calculations:

# for the concentrations, make them into number of particles per L
diam..cmBES = 0.000007
density..gm.cm3 = 1.05
density..mg.cm3 = 1050
volumeBES = (4/3)*pi*((diam..cmBES/2)^3)
mass1particleBES = volumeBES * density..mg.cm3 
mass1particleBES
# so the mass of one particle is now in mg - so let's make our concentrations into number of particles
conc.mgLBES <- c(0.22,0.44,0.88,1.8,3.5,7.0,14,32,70,150) #in mg/L
conc.partLBES <- c(0.22/mass1particleBES,0.44/mass1particleBES,0.88/mass1particleBES,1.8/mass1particleBES,3.5/mass1particleBES,
                   7.0/mass1particleBES,14/mass1particleBES,32/mass1particleBES,70/mass1particleBES,150/mass1particleBES) #part/L
con.partmLBES <- conc.partLBES/1000 #part/mL
diam..cmKIM = 0.000019
volumeKIM = (4/3)*pi*((diam..cmKIM/2)^2)
mass1particleKIM = volumeKIM*density..mg.cm3 
mass1particleKIM
con.mgLKIM <- c(1,5,10,20,30,40,60,80)
con.partLKIM <- c(1/mass1particleKIM,5/mass1particleKIM,10/mass1particleKIM,20/mass1particleKIM,30/mass1particleKIM,
                  40/mass1particleKIM,60/mass1particleKIM,80/mass1particleKIM) #part/L
con.partmLKIM <- con.partLKIM/1000 #part/mL


#run the model for EC50
EC50 <- drm(responseBES2~ con.partmLBES, fct = LL.4()) #using the LL.4 one which is four parameter Log-logistic function with ED50 as parameter and a lower limit at 0
summary(EC50)

#use the formula along with EC50 measurement to create dose response curve
#formula: y = bottom + ((top-bottom)/(1+10^((logEC50-X)*HillSlope)))
#where bottom is the y value at the bottom of the plateau (i.e. at lowest concentration)
#top is y value at the top of the plateau (converse of above)
#logEC50 is the X value when the response is halfway between bottom and top, Hill slope is -1

#create dose response function for EC50 - we're doing this as the relative decrease in reproduction
EC50fun <- function(x) {
  d = 1.5260e-01 
  c = 2.9619e-02 
  e = 2.4196e+11
  hill = -1
  b = -1.8824e+01
  y = c + ((d - c)/(1+((x)/(e))^(b)))
}

#now do model for LC50
LC50 <- drm(mortalityKIM~ con.partmLKIM, fct = LL.4()) #using the LL.4 one which is four parameter Log-logistic function with ED50 as parameter and a lower limit at 0
summary(LC50)

#create dose response function for LC50
LC50fun <- function(x) {
  d = 1.2163e+00
  c = -8.6477e-04  
  e = 1.4030e+05
  hill = -1
  b = -2.7187e+00
  y = c + ((d - c)/(1+((x)/(e))^(b)))
}

############## create a plot showing the dose-response curves:

#make a theme
theme_drc <- function(){
  color.background = 'white'
  color.grid.major = 'black'
  color.axis.text = 'black'
  color.axis.title = 'black'
  color.title = 'black'
  theme_bw(base_size = 9) + 
    theme(panel.background = element_rect(fill=color.background,color = color.background)) +
    theme(plot.background = element_rect(fill = color.background, color = color.background)) +
    theme(panel.border = element_rect(colour = 'black')) +
    theme(panel.grid.major = element_line(colour = 'grey75')) + 
    theme(panel.grid.minor = element_blank()) + 
    theme(axis.ticks = element_blank()) +
    theme(plot.title = element_text(color = color.title, size = 15, vjust = 1.25)) +
    theme(axis.text.x = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.text.y = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.title.x = element_text(size = 15, color = color.axis.title, vjust = 0)) +
    theme(axis.title.y = element_text(size = 15, color = color.axis.title, vjust = 1.25)) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(axis.line.x = element_line(color="black", size = 0.15),
          axis.line.y = element_line(color="black", size = 0.15)) +
    theme(strip.background = element_blank(),
          strip.placement = 'outside',
          strip.text = element_text(size = 10))+
    theme(legend.position = 'right')
}

#create more values to plot over
more.BES.vals <- seq(1166650145, 6e+11, 5988333499)
more.KIM.vals <- seq(2519.271, 245041.677, 2490.224)
extendKIM <- rename(data.frame(cbind((seq(251541.671,300000, 1938.333)), (rep.int(1, 26)))), 
                    more.KIM.vals = X1, LCresp = X2)
ECresp <- as.numeric(lapply(more.BES.vals, EC50fun))
LCresp <- as.numeric(lapply(more.KIM.vals, LC50fun))
ECdata <- data.frame(cbind(more.BES.vals, ECresp))
LCdatat <- data.frame(cbind(more.KIM.vals, LCresp))
LCdata <- rbind(LCdatat, extendKIM)


ECrespcurve <- ggplot(data = ECdata, aes(x = more.BES.vals, y = ECresp)) +
  #geom_point(aes(x = more.BES.vals, y = ECresp))+
  geom_line(aes(x = more.BES.vals, y = ECresp), size = 2, colour = 'red3')+
  theme_drc() +
  labs(x = 'Concentration of Particles (Particles/mL)', y = 'Relative Decrease in Reproduction', 
       title = 'Decrease in Reproduction From Increased Plastic Concentration')
LCrespcurve <- ggplot(data = LCdata, aes(x = more.KIM.vals, y = LCresp)) +
  #geom_point(aes(x = more.BES.vals, y = ECresp))+
  geom_line(aes(x = more.KIM.vals, y = LCresp), size = 2, colour = 'red3')+
  theme_drc() +
  labs(x = 'Concentration of Particles (Particles/mL)', y = 'Mortality Due to Plastic Pollution', 
       title = 'Mortality From Increased Plastic Concentration') 

DRCplot <- plot_grid(ECrespcurve, LCrespcurve)

###################################### Actual Environmental Concentration Calcultations
# so now the challenge is to get realistic estimates for the amount of plastic in the environment
# we want the low medium high of what we see in nature
# there should be something with a linear regression in terms of size of mesh and number of particles
# Roland Gyres has a supplemental material table with year and amount of plastic and then creats a model to show us in a 
# certain time period what the amount of plastic will be in the future - use those values to make estimates for the 
# concentrations we want to use --- use these values to make estimates forthe concentrations we want to use
# I want low, medium high values - take Kennedy's spreadsheet with concentrations of plastic found in nature in different studies
# and that includes the paper, max, concentration average concentration etc. 
# Alexander Terhali also talks aobut nano-particles 

# so from Covernton et al. 2019, we can use their regression of mesh size and plastic particles to figure out what we need to do.
# so for my mesh size, I would need it to be smaller than the smallest particle which is 70nm in diameter, so I'm going to say I'm
# using a 65nm mesh or 0.065um or 0.000065mm mesh 
# from kennedy's data: max = 1.77 part/mL with 0.08mm mesh, average is 0.05 part/mL with 0.333mm and  min = 0.000000028part/mL with 0.3mm 
# so if I take the data from Garth's paper and use their measurements to scale my measurements I can understand what happens at my mesh size
# fitting an power function to the data gives: y = 26.412x^-1.743 -- so by plugging in our two mesh sizes (in microns so 80 and 0.065um) we 
# can get a scaling factor that we can then apply to our data

# we decided to use 0.190um mesh instead to correspond with the size of the particles used  by Kim et al. 2017

### mesh data
# mesh_data = read.csv('C:/Users/coleb/Dropbox/Daphnia Model/Coverinton_mesh_data_my_alterations.csv')
# 
# #add log transformed column
# mesh_data = mesh_data %>% 
#   mutate(conc_m3_log = log(conc)) %>% 
#   mutate(conc_ml_log = log(conc_ml))
# 
# #grab equation 'stat_smooth_func' from devtools
# source_gist("524eade46135f6348140")
# 
# #plot it
# ggplot(data = mesh_data, aes(x = mesh_mm, y = conc_ml)) +
#   stat_smooth_func(geom='text', method = 'lm', hjust = 0, parse = TRUE) +
#   geom_smooth(method = loess, formula = y ~ x) +
#   geom_point()
# new_mesh_data = mesh_data %>% 
#   group_by(mesh_mm) %>% 
#   summarize(conc_ml = mean(conc_ml)) %>% 
#   mutate(conc_ml_log = log(conc_ml))
# 
# ggplot(data = new_mesh_data, aes(x = mesh_mm, y = conc_ml_log)) +
#   stat_smooth_func(geom='text', method = 'lm', hjust = 0, parse = TRUE) +
#   geom_smooth(method = lm, formula = y ~ x)



#mean min max from kennedy's data
min = 0.000000028
minmesh = 0.3
avg = 0.05
avgmesh = 0.333
max = 1.77
maxmesh = 0.08
mymesh = 0.00019


ggplot(data = new_mesh_data, aes(x=mesh_mm, y=conc_ml)) +
  geom_point()

mesh333um = 26.412*(`^`(333,-1.743))
mesh300um = 26.412*(`^`(300,-1.743))
mesh80um = 26.412*(`^`(80,-1.743))
mesh0.190um = 26.412*(`^`(0.065,-1.743))
# mesh0.190um = 9757.5*(`^`(0.190,-1.511))
# mesh333um = 9757.5*(`^`(333,-1.511))
# mesh300um = 9757.5*(`^`(300,-1.511))
# mesh80um = 9757.5*(`^`(80,-1.511))
# mesh0.190um = exp(6.97+(-21.1*0.000065))/1000000
# mesh200um = exp(6.97+(-21.1*0.2))*1000000
# mesh80um = exp(6.97+(-0.0211*80))
# mesh333um = exp(6.97+(-21.1*0.333))
# mesh300um = exp(6.85+(-21.1*0.300))


scalingfactor_avg = mesh0.190um/mesh333um
scalingfactor_min = mesh0.190um/mesh300um
scalingfactor_max = mesh0.190um/mesh80um

current <- c(min*scalingfactor_min, avg*scalingfactor_avg, max*scalingfactor_max)

############################################################# future concentrations

#
plastic_production_polymer <- data.frame(cbind(years, plastic))
plastic_waste <- data.frame(cbind(years1, prod))

current_plastic_plot <- ggplot(data = plastic_waste, aes(x = years1, y = prod)) +
  geom_smooth(method = 'loess', formula = y ~ x^2) +
  #annotate(geom = 'text', label = 'y = 1.1296x^3 - 0.3254x^2 + 6.2593x + 1.3333', x = 1980, y = 350, fontface = 'italic') +
  theme1()+
  labs(x = 'Year', y = 'Plastic Waste (Mt)', title = 'Function-Fit Plot of Current Plastic Waste')
current_plastic_plot

#future plastic

future_formula <- function(x) {
  conc = 1.1667*((x)^3) - 0.7381*((x)^2) + 7.619*(x) + 0.0952
}
current_plastic <- future_formula(6.3) #for 2013 since that's when our max in the experiments were 

future_years <- c(10, 15)
future_production <- future_formula(future_years)
future_production_ratio <- future_production/current_plastic

future_concentrations2050 = current*future_production_ratio[1]
future_concentrations2100 = current*future_production_ratio[2]

############## Run the model

#now create a discretized vector of pollution levels we'll be looking at. Let's use 1 to 100mg/L
pollution_real_current = seq(current[1],current[3],by = (current[3]-current[1])/100)
pollution_real_2050 = seq (3.959948e-02,2.500163e+05, by = 2500.163)
pollution_real_2100 = seq (1.316145e-01,8.309646e+05, by = 8309.645)

phi100real_current <- as.numeric(lapply(pollution_real_current, EC50fun))
alpha100real_current <- as.numeric(lapply(pollution_real_current, LC50fun))
phi100real_2050 <- as.numeric(lapply(pollution_real_2050, EC50fun))
alpha100real_2050 <- as.numeric(lapply(pollution_real_2050, LC50fun))
phi100real_2100 <- as.numeric(lapply(pollution_real_2100, EC50fun))
alpha100real_2100 <- as.numeric(lapply(pollution_real_2100, LC50fun))

###################################### Loop into a results matrix - do this thrice, with the real concentrations
#make a theme
theme1 <- function(){
  color.background = 'white'
  color.grid.major = 'black'
  color.axis.text = 'black'
  color.axis.title = 'black'
  color.title = 'black'
  theme_bw(base_size = 9) + 
    theme(panel.background = element_rect(fill=color.background,color = color.background)) +
    theme(plot.background = element_rect(fill = color.background, color = color.background)) +
    theme(panel.border = element_rect(colour = 'black')) +
    theme(panel.grid.major = element_blank()) + 
    theme(panel.grid.minor = element_blank()) + 
    theme(axis.ticks = element_blank()) +
    theme(plot.title = element_text(color = color.title, size = 15, vjust = 1.25)) +
    theme(axis.text.x = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.text.y = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.title.x = element_text(size = 18, color = color.axis.title, vjust = 0)) +
    theme(axis.title.y = element_text(size = 18, color = color.axis.title, vjust = 1.25)) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(axis.line.x = element_line(color="black", size = 0.15),
          axis.line.y = element_line(color="black", size = 0.15)) +
    theme(strip.background = element_blank(),
          strip.placement = 'outside',
          strip.text = element_text(size = 10))+
    theme(legend.position = 'right')
}
########################################## CURRENT CONCENTRATIONS

#run lsoda to do the solving for me
#make a matrix for the results of the simulations etc. 
sim.matrix.real <- matrix(nrow = 150,ncol = 100)

#run for loop doing the desolve at each concentration level
for(i in 1:100) {
  
  #starting conditions
  N0 <- 50
  #set amount of time steps to run in simulation
  TT <- seq(1,150,1)
  #give parameters
  alpha <- alpha100real_current[i]
  phi <- phi100real_current[i] 
  k <- 5000
  b <- pcbr
  u <- pcdr
  parms <- c(b,phi,k,u,alpha)
  #run lsoda, which is an ODE solver in the deSolve package, and save the results into an object
  sim.results.real <- lsoda(N0, TT, daphgrow, parms)
  
  sim.matrix.real[,i] <- sim.results.real[,2] #add the results to the matrix one by one
}
growth_change_cur <- sim.matrix.real[150,]

## plot results for 1, 16, 33
pollution_real_current[100]
#pick the columns I want
select_res.real <- data.frame(cbind(c(1:150),sim.matrix.real[,1], sim.matrix.real[,50], sim.matrix.real[,75], sim.matrix.real[,100]))
colnames(select_res.real) <- c('Day', 'Low', 'Med', 'High', 'VeryHigh')

deterministic_current_plot <- ggplot() +
  geom_line(data = select_res.real, aes(x = Day, y = Low), colour = 'green4', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = Med), colour = 'blue3', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = High), colour = 'orange3', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = VeryHigh), colour = 'red4', size =1) +
  theme1() +
  labs(x = '', y = 'Population Abundance', title = 'Current Plastic Concentrations')+
  annotate('text', x = 100, y = 4800, label = 'Min = 0 particles/mL', size = 5, colour = 'green4')+
  annotate('text', x = 100, y = 4550, label = 'Median = ~32000 particles/mL', size = 5, colour = 'blue3')+
  annotate('text', x = 100, y = 4090, label = 'Q3 = ~50000 particles/mL', size = 5, colour = 'orange3')+
  annotate('text', x = 100, y = 3350, label = 'Max = ~66000 particles/mL', size = 5, colour = 'red4')
deterministic_current_plot

########################################## 2050 CONCENTRATIONS

#run lsoda to do the solving for me
#make a matrix for the results of the simulations etc. 
sim.matrix.real <- matrix(nrow = 150,ncol = 100)

#run for loop doing the desolve at each concentration level
for(i in 1:100) {
  
  #starting conditions
  N0 <- 50
  #set amount of time steps to run in simulation
  TT <- seq(1,150,1)
  #give parameters
  alpha <- alpha100real_2050[i]
  phi <- phi100real_2050[i] 
  k <- 5000
  b <- pcbr
  u <- pcdr
  parms <- c(b,phi,k,u,alpha)
  #run lsoda, which is an ODE solver in the deSolve package, and save the results into an object
  sim.results.real <- lsoda(N0, TT, daphgrow, parms)
  
  sim.matrix.real[,i] <- sim.results.real[,2] #add the results to the matrix one by one
}

growth_change_2050 <- sim.matrix.real[150,]
## plot results for 1, 16, 33
pollution_real_2050[34]
#pick the columns I want
select_res.real <- data.frame(cbind(c(1:150),sim.matrix.real[,1], sim.matrix.real[,25], sim.matrix.real[,34], sim.matrix.real[,44]))
colnames(select_res.real) <- c('Day', 'Low', 'Med', 'High', 'VeryHigh')

deterministic_2050_plot <- ggplot() +
  geom_line(data = select_res.real, aes(x = Day, y = Low), colour = 'green4', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = Med), colour = 'blue3', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = High), colour = 'orange3', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = VeryHigh), colour = 'red4', size =1) +
  theme1() +
  labs(x = '', y = 'Population Abundance', title = 'Projected 2050 Plastic Concentrations')+
  annotate('text', x = 100, y = 4750, label = 'Min = 0 particles/mL', size = 5, colour = 'green4')+
  annotate('text', x = 100, y = 3600, label = '25th Percentile = ~60000 particles/mL', size = 5, colour = 'blue3')+
  annotate('text', x = 100, y = 2200, label = '35th Percentile = ~83000 particles/mL', size = 5, colour = 'orange3')+
  annotate('text', x = 100, y = 450, label = '45th Percentile = ~108000 particles/mL', size = 5, colour = 'red4')
deterministic_2050_plot

########################################## 2100 CONCENTRATIONS

#run lsoda to do the solving for me
#make a matrix for the results of the simulations etc. 
sim.matrix.real <- matrix(nrow = 150,ncol = 100)

#run for loop doing the desolve at each concentration level
for(i in 1:100) {
  
  #starting conditions
  N0 <- 50
  #set amount of time steps to run in simulation
  TT <- seq(1,150,1)
  #give parameters
  alpha <- alpha100real_2100[i]
  phi <- phi100real_2100[i] 
  k <- 5000
  b <- pcbr
  u <- pcdr
  parms <- c(b,phi,k,u,alpha)
  #run lsoda, which is an ODE solver in the deSolve package, and save the results into an object
  sim.results.real <- lsoda(N0, TT, daphgrow, parms)
  
  sim.matrix.real[,i] <- sim.results.real[,2] #add the results to the matrix one by one
}

growth_change_2100 <- sim.matrix.real[150,]
## plot results for 1, 16, 33
pollution_real_2100[15]
#pick the columns I want
select_res.real <- data.frame(cbind(c(1:150),sim.matrix.real[,1], sim.matrix.real[,8], sim.matrix.real[,11], sim.matrix.real[,14]))
colnames(select_res.real) <- c('Day', 'Low', 'Med', 'High', 'VeryHigh')

deterministic_2100_plot <- ggplot() +
  geom_line(data = select_res.real, aes(x = Day, y = Low), colour = 'green4', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = Med), colour = 'blue3', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = High), colour = 'orange3', size =1) +
  geom_line(data = select_res.real, aes(x = Day, y = VeryHigh), colour = 'red4', size =1) +
  theme1() +
  labs(x = 'Day', y = 'Population Abundance', title = 'Projected 2100 Plastic Concentrations')+
  annotate('text', x = 100, y = 4750, label = 'Low = 0 particles/mL', size = 5, colour = 'green4')+
  annotate('text', x = 100, y = 3600, label = '8th Percentile = ~60000 particles/mL', size = 5, colour = 'blue3')+
  annotate('text', x = 100, y = 2200, label = '11th Percentile = ~83000 particles/mL', size = 5, colour = 'orange3')+
  annotate('text', x = 100, y = 450, label = '14th Percentile = ~108000 particles/mL', size = 5, colour = 'red4')
deterministic_2100_plot

###################### MAKE SOME SORT OF PLOT TO SHOW HOW THE EFFCET GOES FROM NOT BAD TO BAD REALLY QUICKLY

conc_growth_data_2050 <- data.frame(cbind(pollution_real_2050, growth_change_2050))

FinalPopPlot2050 <- ggplot(data = conc_growth_data_2050) +
  geom_line(aes(x = pollution_real_2050, y = growth_change_2050), size = 1) + 
  labs(x = 'Microplastic Concentration (Particles/mL)', y = 'Final Population Abundance', title = 'Changes in Final 
       Population Abundance vs. Microplastic Concentrations') +
  theme1() +
  scale_x_continuous(limits = c(0,130000))+
  geom_vline(xintercept = 85000, colour = 'red3', linetype = 'dashed')+
  geom_vline(xintercept = 122000, colour = 'red3', linetype = 'dashed') +
  annotate('text', x = 70000, y = 2000, label = "50% Pop'n \nReduction", size = 5, colour = 'black')+
  annotate('text', x = 108000, y = 4000, label = "Pop'n \nExtirpation", size = 5, colour = 'black')+
  annotate('segment', x = 108000, xend = 120000, y = 3650, yend = 3200, colour = 'black')+
  annotate('segment', x = 70000, xend = 82000, y = 1650, yend = 1200, colour = 'black')
  
FinalPopPlot2050

############################################ Simulations for Current Concentrations

## make quick (sort of plot) for the current, medium and high concentrations 
pb1 = txtProgressBar(min = 0, max = 100, initial = 0, char = ".Don't Touch, Running..", style = 1, width = 20)

#make the matricies
sim.matrix.low <- matrix(nrow = 100,ncol = 10)
sim.matrix.med <- matrix(nrow = 100,ncol = 10)
sim.matrix.high <- matrix(nrow = 100,ncol = 10)
sim.matrix.vhigh <- matrix(nrow = 100,ncol = 10)

#run the sim
N0s <- c(5, 10, 50, 100)
for (j in N0s) {
  
  x0 <- c(N = j)
  
  for (i in 1:10) {
  
  #make the individual propensity function
  a <- c("(b-phi)*N*(1-(N/k))", "(u+alpha)*N")
  #make state change matrix
  nu <- matrix(c(+1,-1), ncol = 2)
  #time units
  tf = 175
  #method
  method <- "OTL"
  #sim name
  simName <- "daphgrow"

  #low
  parms1 <- c(b=pcbr, phi=phi100real_current[1], k=5000, u=pcdr, alpha=alpha100real_current[1]) #set parameters
  sim.results.low <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                         verbose = FALSE, censusInterval = 1)) #run simulation
  temp.low <- sim.results.low$data #take just the data part of the simulation and put it in a new variable
  rows <- length(temp.low)/2 #determine the length of the new variable 
  if (rows < 100) { #this s for simulations that go to zero and stop, so we can keep in the 'zeros'
    temp <- matrix(nrow = (100-rows), ncol = 2) #make a matrix of the size to make up the difference between where sim stopped and 100
    temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100)) #fill it with the time stamps and 0s
    temp.low <- rbind(temp.low, temp) #bind them so you have a matrix with 100 rows
  }
  sim.matrix.low[,i] <- temp.low[c(1:100),2] #bind the results part of the matrix to the overall sim results
  
  #medium
  parms2 <- c(b=pcbr, phi=phi100real_current[50], k=5000, u=pcdr, alpha=alpha100real_current[50])
  sim.results.med <- suppressWarnings(ssa(x0, a, nu, parms2, tf, method, simName,
                         verbose = FALSE, censusInterval = 1))
  temp.med <- sim.results.med$data
  rows <- length(temp.med)/2
  if (rows < 100) { 
    temp <- matrix(nrow = (100-rows), ncol = 2)
    temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
    temp.med <- rbind(temp.med, temp)
  }
  sim.matrix.med[,i] <- temp.med[c(1:100),2]
  
  #high
  parms3 <- c(b=pcbr, phi=phi100real_current[75], k=5000, u=pcdr, alpha=alpha100real_current[75])
  sim.results.high <- suppressWarnings(ssa(x0, a, nu, parms3, tf, method, simName,
                          verbose = FALSE, censusInterval = 1))
  temp.high <- sim.results.high$data
  rows <- length(temp.high)/2
  if (rows < 100) { 
    temp <- matrix(nrow = (100-rows), ncol = 2)
    temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
    temp.high <- rbind(temp.high, temp)
  }
  sim.matrix.high[,i] <- temp.high[c(1:100),2]
  
  #very high
  parms4 <- c(b=pcbr, phi=phi100real_current[100], k=5000, u=pcdr, alpha=alpha100real_current[100])
  sim.results.vhigh <- suppressWarnings(ssa(x0, a, nu, parms4, tf, method, simName,
                          verbose = FALSE, censusInterval = 1))
  temp.vhigh <- sim.results.vhigh$data
  rows <- length(temp.vhigh)/2
  if (rows < 100) { 
    temp <- matrix(nrow = (100-rows), ncol = 2)
    temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
    temp.vhigh <- rbind(temp.vhigh, temp)
  }
  sim.matrix.vhigh[,i] <- temp.vhigh[c(1:100),2]
  setTxtProgressBar(pb1,i)
  
  }
  
  name <- paste('SimLow', j, sep = '')
  assign(name, sim.matrix.low)
  name <- paste('SimMed', j, sep = '')
  assign(name, sim.matrix.med)
  name <- paste('SimHigh', j, sep = '')
  assign(name, sim.matrix.high)
  name <- paste('SimVhigh', j, sep = '')
  assign(name, sim.matrix.vhigh)

}

#make into dataframes
low5 <- data.frame(SimLow5);low10 <- data.frame(SimLow10);low50 <- data.frame(SimLow50);low100 <- data.frame(SimLow100) 
med5 <- data.frame(SimMed5);med10 <- data.frame(SimMed10);med50 <- data.frame(SimMed50);med100 <- data.frame(SimMed100)  
high5 <- data.frame(SimHigh5);high10 <- data.frame(SimHigh10);high50 <- data.frame(SimHigh50);high100 <- data.frame(SimHigh100)    
vhigh5 <- data.frame(SimVhigh5);vhigh10 <- data.frame(SimVhigh10);vhigh50 <- data.frame(SimVhigh50);vhigh100 <- data.frame(SimVhigh100) 

#add proper names and a time variable as well
prefix <- 'Sim'
suffix <- seq(1:10)

names <- paste(prefix, suffix, sep = '')
colnames(low5) <- names;colnames(low10) <- names;colnames(low50) <- names;colnames(low100) <- names
colnames(med5) <- names;colnames(med10) <- names;colnames(med50) <- names;colnames(med100) <- names
colnames(high5) <- names;colnames(high10) <- names;colnames(high50) <- names;colnames(high100) <- names
colnames(vhigh5) <- names;colnames(vhigh10) <- names;colnames(vhigh50) <- names;colnames(vhigh100) <- names


time <- data.frame(time = seq(1:100))

low5 <- cbind(time, low5);low10 <- cbind(time, low10);low50 <- cbind(time, low50);low100 <- cbind(time, low100)
med5 <- cbind(time, med5);med10 <- cbind(time, med10);med50 <- cbind(time, med50);med100 <- cbind(time, med100) 
high5 <- cbind(time, high5);high10 <- cbind(time, high10);high50 <- cbind(time, high50);high100 <- cbind(time, high100) 
vhigh5 <- cbind(time, vhigh5);vhigh10 <- cbind(time, vhigh10);vhigh50 <- cbind(time, vhigh50);vhigh100 <- cbind(time, vhigh100) 

#make a function to plot it all at once in ggplot
theme2 <- function(){
  color.background = 'white'
  color.grid.major = 'black'
  color.axis.text = 'black'
  color.axis.title = 'black'
  color.title = 'black'
  theme_bw(base_size = 9) + 
    theme(panel.background = element_rect(fill=color.background,color = color.background)) +
    theme(plot.background = element_rect(fill = color.background, color = color.background)) +
    theme(panel.border = element_rect(colour = 'black')) +
    theme(panel.grid.major = element_blank()) + 
    theme(panel.grid.minor = element_blank()) + 
    theme(axis.ticks = element_blank()) +
    theme(plot.title = element_text(color = color.title, size = 15, vjust = 1.25)) +
    theme(axis.text.x = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.text.y = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.title.x = element_blank()) +
    theme(axis.title.y = element_text(size = 15, color = color.axis.title, vjust = 1.25)) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(axis.line.x = element_line(color="black", size = 0.15),
          axis.line.y = element_line(color="black", size = 0.15)) +
    theme(strip.background = element_blank(),
          strip.placement = 'outside',
          strip.text = element_text(size = 10))+
    theme(legend.position = 'right')
}
theme3 <- function(){
  color.background = 'white'
  color.grid.major = 'black'
  color.axis.text = 'black'
  color.axis.title = 'black'
  color.title = 'black'
  theme_bw(base_size = 9) + 
    theme(panel.background = element_rect(fill=color.background,color = color.background)) +
    theme(plot.background = element_rect(fill = color.background, color = color.background)) +
    theme(panel.border = element_rect(colour = 'black')) +
    theme(panel.grid.major = element_blank()) + 
    theme(panel.grid.minor = element_blank()) + 
    theme(axis.ticks = element_blank()) +
    theme(plot.title = element_text(color = color.title, size = 15, vjust = 1.25)) +
    theme(axis.text.x = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.text.y = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.title.x = element_blank()) +
    theme(axis.title.y = element_blank()) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(axis.line.x = element_line(color="black", size = 0.15),
          axis.line.y = element_line(color="black", size = 0.15)) +
    theme(strip.background = element_blank(),
          strip.placement = 'outside',
          strip.text = element_text(size = 10))+
    theme(legend.position = 'right')
}
theme4 <- function(){
  color.background = 'white'
  color.grid.major = 'black'
  color.axis.text = 'black'
  color.axis.title = 'black'
  color.title = 'black'
  theme_bw(base_size = 9) + 
    theme(panel.background = element_rect(fill=color.background,color = color.background)) +
    theme(plot.background = element_rect(fill = color.background, color = color.background)) +
    theme(panel.border = element_rect(colour = 'black')) +
    theme(panel.grid.major = element_blank()) + 
    theme(panel.grid.minor = element_blank()) + 
    theme(axis.ticks = element_blank()) +
    theme(plot.title = element_text(color = color.title, size = 15, vjust = 1.25)) +
    theme(axis.text.x = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.text.y = element_text(size = 12, color = color.axis.text)) + 
    theme(axis.title.x = element_text(size = 15, color = color.axis.title, vjust = 0)) +
    theme(axis.title.y = element_blank()) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(axis.line.x = element_line(color="black", size = 0.15),
          axis.line.y = element_line(color="black", size = 0.15)) +
    theme(strip.background = element_blank(),
          strip.placement = 'outside',
          strip.text = element_text(size = 10))+
    theme(legend.position = 'right')
}
plotall1 <- function(df1, df2, df3, df4, level) { #call all necessary dataframes
  #figure out how many pops went extinct
  df1row <- df1[100,]
  count1 = 0
  for (i in df1row) {
    if(i == 0){
      count1 = count1 + 1
    }
  }
  df2row <- df2[100,]
  count2 = 0
  for (i in df2row) {
    if(i == 0){
      count2 = count2 + 1
    }
  }
  df3row <- df3[100,]
  count3 = 0
  for (i in df3row) {
    if(i == 0){
      count3 = count3 + 1
    }
  }
  df4row <- df4[100,]
  count4 = 0
  for (i in df4row) {
    if(i == 0){
      count4 = count4 + 1
    }
  }
  #make the labels of how many pop'ns went extinct
  label1 = paste('Starting Population \n Abundance =', level, sep = ' ')
  a = "ext:"
  label2 = paste(a, count1, sep = '');label3 = paste(a, count2, sep = '')
  label4 = paste(a, count3, sep = '');label5 = paste(a, count4, sep = '')
  
  
  
  stoch.plot <- ggplot(data = df1,aes(df1[,1])) + theme2() + #make initial plot
    labs(x = 'Time (Days)', y = 'Population Abundance') +
    annotate('text', x = 2, y = 4000, label = label2, size = 5, colour = 'green4')+
    annotate('text', x = 2, y = 2900, label = label3, size = 5, colour = 'blue3')+
    annotate('text', x = 2, y = 1900, label = label4, size = 5, colour = 'orange3')+
    annotate('text', x = 2, y = 1000, label = label5, size = 5, colour = 'red4')
  for (i in names(df1)[-1]){ #add each grouping as necessary, specifying the dataframe
    stoch.plot <- stoch.plot + geom_line(aes_string(y=i), colour = 'green4', size =0.01) 
  }
  for (i in names(df2)[-1]){ #must specify data argument if not the df that was used to make original plot
    stoch.plot <- stoch.plot + geom_line(data = df2, aes_string(y=i), colour = 'blue3', size =0.01)
  }
  for (i in names(df3)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df3, aes_string(y=i), colour = 'orange3', size =0.01)
  }
  for (i in names(df4)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df4, aes_string(y=i), colour = 'red4', size =0.01)
  }
  return(stoch.plot)
}
plotall2 <- function(df1, df2, df3, df4, level) { #call all necessary dataframes
  #figure out how many pops went extinct
  df1row <- df1[100,]
  count1 = 0
  for (i in df1row) {
    if(i == 0){
      count1 = count1 + 1
    }
  }
  df2row <- df2[100,]
  count2 = 0
  for (i in df2row) {
    if(i == 0){
      count2 = count2 + 1
    }
  }
  df3row <- df3[100,]
  count3 = 0
  for (i in df3row) {
    if(i == 0){
      count3 = count3 + 1
    }
  }
  df4row <- df4[100,]
  count4 = 0
  for (i in df4row) {
    if(i == 0){
      count4 = count4 + 1
    }
  }
  #make the labels of how many pop'ns went extinct
  label1 = paste('Starting Population \n Abundance =', level, sep = ' ')
  a = "ext:"
  label2 = paste(a, count1, sep = '');label3 = paste(a, count2, sep = '')
  label4 = paste(a, count3, sep = '');label5 = paste(a, count4, sep = '')
  
  
  
  stoch.plot <- ggplot(data = df1,aes(df1[,1])) + theme3() + #make initial plot
    labs(x = 'Time (Days)', y = 'Population Abundance') +
    annotate('text', x = 2, y = 4000, label = label2, size = 5, colour = 'green4')+
    annotate('text', x = 2, y = 2900, label = label3, size = 5, colour = 'blue3')+
    annotate('text', x = 2, y = 1900, label = label4, size = 5, colour = 'orange3')+
    annotate('text', x = 2, y = 1000, label = label5, size = 5, colour = 'red4')
  for (i in names(df1)[-1]){ #add each grouping as necessary, specifying the dataframe
    stoch.plot <- stoch.plot + geom_line(aes_string(y=i), colour = 'green4', size =0.01) 
  }
  for (i in names(df2)[-1]){ #must specify data argument if not the df that was used to make original plot
    stoch.plot <- stoch.plot + geom_line(data = df2, aes_string(y=i), colour = 'blue3', size =0.01)
  }
  for (i in names(df3)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df3, aes_string(y=i), colour = 'orange3', size =0.01)
  }
  for (i in names(df4)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df4, aes_string(y=i), colour = 'red4', size =0.01)
  }
  return(stoch.plot)
}
plotall3 <- function(df1, df2, df3, df4, level) { #call all necessary dataframes
  #figure out how many pops went extinct
  df1row <- df1[100,]
  count1 = 0
  for (i in df1row) {
    if(i == 0){
      count1 = count1 + 1
    }
  }
  df2row <- df2[100,]
  count2 = 0
  for (i in df2row) {
    if(i == 0){
      count2 = count2 + 1
    }
  }
  df3row <- df3[100,]
  count3 = 0
  for (i in df3row) {
    if(i == 0){
      count3 = count3 + 1
    }
  }
  df4row <- df4[100,]
  count4 = 0
  for (i in df4row) {
    if(i == 0){
      count4 = count4 + 1
    }
  }
  #make the labels of how many pop'ns went extinct
  label1 = paste('Starting Population \n Abundance =', level, sep = ' ')
  a = "ext:"
  label2 = paste(a, count1, sep = '');label3 = paste(a, count2, sep = '')
  label4 = paste(a, count3, sep = '');label5 = paste(a, count4, sep = '')
  
  
  
  stoch.plot <- ggplot(data = df1,aes(df1[,1])) + theme1() + #make initial plot
    labs(x = 'Time (Days)', y = 'Population Abundance') +
    annotate('text', x = 2, y = 4000, label = label2, size = 5, colour = 'green4')+
    annotate('text', x = 2, y = 2900, label = label3, size = 5, colour = 'blue3')+
    annotate('text', x = 2, y = 1900, label = label4, size = 5, colour = 'orange3')+
    annotate('text', x = 2, y = 1000, label = label5, size = 5, colour = 'red4')
  for (i in names(df1)[-1]){ #add each grouping as necessary, specifying the dataframe
    stoch.plot <- stoch.plot + geom_line(aes_string(y=i), colour = 'green4', size =0.01) 
  }
  for (i in names(df2)[-1]){ #must specify data argument if not the df that was used to make original plot
    stoch.plot <- stoch.plot + geom_line(data = df2, aes_string(y=i), colour = 'blue3', size =0.01)
  }
  for (i in names(df3)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df3, aes_string(y=i), colour = 'orange3', size =0.01)
  }
  for (i in names(df4)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df4, aes_string(y=i), colour = 'red4', size =0.01)
  }
  return(stoch.plot)
}
plotall4 <- function(df1, df2, df3, df4, level) { #call all necessary dataframes
  #figure out how many pops went extinct
  df1row <- df1[100,]
  count1 = 0
  for (i in df1row) {
    if(i == 0){
      count1 = count1 + 1
    }
  }
  df2row <- df2[100,]
  count2 = 0
  for (i in df2row) {
    if(i == 0){
      count2 = count2 + 1
    }
  }
  df3row <- df3[100,]
  count3 = 0
  for (i in df3row) {
    if(i == 0){
      count3 = count3 + 1
    }
  }
  df4row <- df4[100,]
  count4 = 0
  for (i in df4row) {
    if(i == 0){
      count4 = count4 + 1
    }
  }
  #make the labels of how many pop'ns went extinct
  label1 = paste('Starting Population \n Abundance =', level, sep = ' ')
  a = "ext:"
  label2 = paste(a, count1, sep = '');label3 = paste(a, count2, sep = '')
  label4 = paste(a, count3, sep = '');label5 = paste(a, count4, sep = '')
  
  
  
  stoch.plot <- ggplot(data = df1,aes(df1[,1])) + theme4() + #make initial plot
    labs(x = 'Time (Days)', y = 'Population Abundance') +
    annotate('text', x = 2, y = 4000, label = label2, size = 5, colour = 'green4')+
    annotate('text', x = 2, y = 2900, label = label3, size = 5, colour = 'blue3')+
    annotate('text', x = 2, y = 1900, label = label4, size = 5, colour = 'orange3')+
    annotate('text', x = 2, y = 1000, label = label5, size = 5, colour = 'red4')
  for (i in names(df1)[-1]){ #add each grouping as necessary, specifying the dataframe
    stoch.plot <- stoch.plot + geom_line(aes_string(y=i), colour = 'green4', size =0.01) 
  }
  for (i in names(df2)[-1]){ #must specify data argument if not the df that was used to make original plot
    stoch.plot <- stoch.plot + geom_line(data = df2, aes_string(y=i), colour = 'blue3', size =0.01)
  }
  for (i in names(df3)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df3, aes_string(y=i), colour = 'orange3', size =0.01)
  }
  for (i in names(df4)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df4, aes_string(y=i), colour = 'red4', size =0.01)
  }
  return(stoch.plot)
}

#make plot
stoch.plot5 <- plotall1(low5, med5, high5, vhigh5, 5)
stoch.plot10 <- plotall2(low10, med10, high10, vhigh10, 10)
stoch.plot50 <- plotall3(low50, med50, high50, vhigh50, 50)
stoch.plot100 <- plotall4(low100, med100, high100, vhigh100, 100)

stoch.plots.cur <- plot_grid(stoch.plot5, stoch.plot10, stoch.plot50, stoch.plot100, nrow = 2, ncol = 2, 
                         rel_widths = c(1,1,1,1), rel_heights = c(0.7, 0.7, 0.7, 0.7), hjust = c(-6,-4, -6,-4), 
                         labels = c('A', 'B', 'C', 'D')) 
stoch.plots.cur

############################################ Simulations for 2050 Concentrations

## make quick (sort of plot) for the current, medium and high concentrations 
pb1 = txtProgressBar(min = 0, max = 100, initial = 0, char = ".Don't Touch, Running..", style = 1, width = 20)

#make the matricies
sim.matrix.low <- matrix(nrow = 100,ncol = 10)
sim.matrix.med <- matrix(nrow = 100,ncol = 10)
sim.matrix.high <- matrix(nrow = 100,ncol = 10)
sim.matrix.vhigh <- matrix(nrow = 100,ncol = 10)

#run the sim
N0s <- c(5, 10, 50, 100)
for (j in N0s) {
  
  x0 <- c(N = j)
  
  for (i in 1:10) {
    
    #make the individual propensity function
    a <- c("(b-phi)*N*(1-(N/k))", "(u+alpha)*N")
    #make state change matrix
    nu <- matrix(c(+1,-1), ncol = 2)
    #time units
    tf = 175
    #method
    method <- "OTL"
    #sim name
    simName <- "daphgrow"
    
    #low
    parms1 <- c(b=pcbr, phi=phi100real_2050[1], k=5000, u=pcdr, alpha=alpha100real_2050[1]) #set parameters
    sim.results.low <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, censusInterval = 1)) #run simulation
    temp.low <- sim.results.low$data #take just the data part of the simulation and put it in a new variable
    rows <- length(temp.low)/2 #determine the length of the new variable 
    if (rows < 100) { #this s for simulations that go to zero and stop, so we can keep in the 'zeros'
      temp <- matrix(nrow = (100-rows), ncol = 2) #make a matrix of the size to make up the difference between where sim stopped and 100
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100)) #fill it with the time stamps and 0s
      temp.low <- rbind(temp.low, temp) #bind them so you have a matrix with 100 rows
    }
    sim.matrix.low[,i] <- temp.low[c(1:100),2] #bind the results part of the matrix to the overall sim results
    
    #medium
    parms2 <- c(b=pcbr, phi=phi100real_2050[25], k=5000, u=pcdr, alpha=alpha100real_2050[25])
    sim.results.med <- suppressWarnings(ssa(x0, a, nu, parms2, tf, method, simName,
                                            verbose = FALSE, censusInterval = 1))
    temp.med <- sim.results.med$data
    rows <- length(temp.med)/2
    if (rows < 100) { 
      temp <- matrix(nrow = (100-rows), ncol = 2)
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
      temp.med <- rbind(temp.med, temp)
    }
    sim.matrix.med[,i] <- temp.med[c(1:100),2]
    
    #high
    parms3 <- c(b=pcbr, phi=phi100real_2050[35], k=5000, u=pcdr, alpha=alpha100real_2050[35])
    sim.results.high <- suppressWarnings(ssa(x0, a, nu, parms3, tf, method, simName,
                                             verbose = FALSE, censusInterval = 1))
    temp.high <- sim.results.high$data
    rows <- length(temp.high)/2
    if (rows < 100) { 
      temp <- matrix(nrow = (100-rows), ncol = 2)
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
      temp.high <- rbind(temp.high, temp)
    }
    sim.matrix.high[,i] <- temp.high[c(1:100),2]
    
    #very high
    parms4 <- c(b=pcbr, phi=phi100real_2050[45], k=5000, u=pcdr, alpha=alpha100real_2050[45])
    sim.results.vhigh <- suppressWarnings(ssa(x0, a, nu, parms4, tf, method, simName,
                                              verbose = FALSE, censusInterval = 1))
    temp.vhigh <- sim.results.vhigh$data
    rows <- length(temp.vhigh)/2
    if (rows < 100) { 
      temp <- matrix(nrow = (100-rows), ncol = 2)
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
      temp.vhigh <- rbind(temp.vhigh, temp)
    }
    sim.matrix.vhigh[,i] <- temp.vhigh[c(1:100),2]
    setTxtProgressBar(pb1,i)
    
  }
  
  name <- paste('SimLow', j, sep = '')
  assign(name, sim.matrix.low)
  name <- paste('SimMed', j, sep = '')
  assign(name, sim.matrix.med)
  name <- paste('SimHigh', j, sep = '')
  assign(name, sim.matrix.high)
  name <- paste('SimVhigh', j, sep = '')
  assign(name, sim.matrix.vhigh)
  
}

#make into dataframes
low5 <- data.frame(SimLow5);low10 <- data.frame(SimLow10);low50 <- data.frame(SimLow50);low100 <- data.frame(SimLow100) 
med5 <- data.frame(SimMed5);med10 <- data.frame(SimMed10);med50 <- data.frame(SimMed50);med100 <- data.frame(SimMed100)  
high5 <- data.frame(SimHigh5);high10 <- data.frame(SimHigh10);high50 <- data.frame(SimHigh50);high100 <- data.frame(SimHigh100)    
vhigh5 <- data.frame(SimVhigh5);vhigh10 <- data.frame(SimVhigh10);vhigh50 <- data.frame(SimVhigh50);vhigh100 <- data.frame(SimVhigh100) 

#add proper names and a time variable as well
prefix <- 'Sim'
suffix <- seq(1:10)

names <- paste(prefix, suffix, sep = '')
colnames(low5) <- names;colnames(low10) <- names;colnames(low50) <- names;colnames(low100) <- names
colnames(med5) <- names;colnames(med10) <- names;colnames(med50) <- names;colnames(med100) <- names
colnames(high5) <- names;colnames(high10) <- names;colnames(high50) <- names;colnames(high100) <- names
colnames(vhigh5) <- names;colnames(vhigh10) <- names;colnames(vhigh50) <- names;colnames(vhigh100) <- names


time <- data.frame(time = seq(1:100))

low5 <- cbind(time, low5);low10 <- cbind(time, low10);low50 <- cbind(time, low50);low100 <- cbind(time, low100)
med5 <- cbind(time, med5);med10 <- cbind(time, med10);med50 <- cbind(time, med50);med100 <- cbind(time, med100) 
high5 <- cbind(time, high5);high10 <- cbind(time, high10);high50 <- cbind(time, high50);high100 <- cbind(time, high100) 
vhigh5 <- cbind(time, vhigh5);vhigh10 <- cbind(time, vhigh10);vhigh50 <- cbind(time, vhigh50);vhigh100 <- cbind(time, vhigh100) 



#make plot
stoch.plot5 <- plotall1(low5, med5, high5, vhigh5, 5)
stoch.plot10 <- plotall2(low10, med10, high10, vhigh10, 10)
stoch.plot50 <- plotall3(low50, med50, high50, vhigh50, 50)
stoch.plot100 <- plotall4(low100, med100, high100, vhigh100, 100)

stoch.plots.2050 <- plot_grid(stoch.plot5, stoch.plot10, stoch.plot50, stoch.plot100, nrow = 2, ncol = 2, 
                             rel_widths = c(1,1,1,1), rel_heights = c(0.7, 0.7, 0.7, 0.7), hjust = c(-6,-4, -6,-4), 
                             labels = c('A', 'B', 'C', 'D'))
stoch.plots.2050


############################################ Simulations for 2100 Concentrations

## make quick (sort of plot) for the current, medium and high concentrations 
pb1 = txtProgressBar(min = 0, max = 100, initial = 0, char = ".Don't Touch, Running..", style = 1, width = 20)

#make the matricies
sim.matrix.low <- matrix(nrow = 100,ncol = 10)
sim.matrix.med <- matrix(nrow = 100,ncol = 10)
sim.matrix.high <- matrix(nrow = 100,ncol = 10)
sim.matrix.vhigh <- matrix(nrow = 100,ncol = 10)

#run the sim
N0s <- c(5, 10, 50, 100)
for (j in N0s) {
  
  x0 <- c(N = j)
  
  for (i in 1:10) {
    
    #make the individual propensity function
    a <- c("(b-phi)*N*(1-(N/k))", "(u+alpha)*N")
    #make state change matrix
    nu <- matrix(c(+1,-1), ncol = 2)
    #time units
    tf = 175
    #method
    method <- "OTL"
    #sim name
    simName <- "daphgrow"
    
    #low
    parms1 <- c(b=pcbr, phi=phi100real_2100[1], k=5000, u=pcdr, alpha=alpha100real_2100[1]) #set parameters
    sim.results.low <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, censusInterval = 1)) #run simulation
    temp.low <- sim.results.low$data #take just the data part of the simulation and put it in a new variable
    rows <- length(temp.low)/2 #determine the length of the new variable 
    if (rows < 100) { #this s for simulations that go to zero and stop, so we can keep in the 'zeros'
      temp <- matrix(nrow = (100-rows), ncol = 2) #make a matrix of the size to make up the difference between where sim stopped and 100
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100)) #fill it with the time stamps and 0s
      temp.low <- rbind(temp.low, temp) #bind them so you have a matrix with 100 rows
    }
    sim.matrix.low[,i] <- temp.low[c(1:100),2] #bind the results part of the matrix to the overall sim results
    
    #medium
    parms2 <- c(b=pcbr, phi=phi100real_2100[8], k=5000, u=pcdr, alpha=alpha100real_2100[8])
    sim.results.med <- suppressWarnings(ssa(x0, a, nu, parms2, tf, method, simName,
                                            verbose = FALSE, censusInterval = 1))
    temp.med <- sim.results.med$data
    rows <- length(temp.med)/2
    if (rows < 100) { 
      temp <- matrix(nrow = (100-rows), ncol = 2)
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
      temp.med <- rbind(temp.med, temp)
    }
    sim.matrix.med[,i] <- temp.med[c(1:100),2]
    
    #high
    parms3 <- c(b=pcbr, phi=phi100real_2100[11], k=5000, u=pcdr, alpha=alpha100real_2100[11])
    sim.results.high <- suppressWarnings(ssa(x0, a, nu, parms3, tf, method, simName,
                                             verbose = FALSE, censusInterval = 1))
    temp.high <- sim.results.high$data
    rows <- length(temp.high)/2
    if (rows < 100) { 
      temp <- matrix(nrow = (100-rows), ncol = 2)
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
      temp.high <- rbind(temp.high, temp)
    }
    sim.matrix.high[,i] <- temp.high[c(1:100),2]
    
    #very high
    parms4 <- c(b=pcbr, phi=phi100real_2100[14], k=5000, u=pcdr, alpha=alpha100real_2100[14])
    sim.results.vhigh <- suppressWarnings(ssa(x0, a, nu, parms4, tf, method, simName,
                                              verbose = FALSE, censusInterval = 1))
    temp.vhigh <- sim.results.vhigh$data
    rows <- length(temp.vhigh)/2
    if (rows < 100) { 
      temp <- matrix(nrow = (100-rows), ncol = 2)
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100))
      temp.vhigh <- rbind(temp.vhigh, temp)
    }
    sim.matrix.vhigh[,i] <- temp.vhigh[c(1:100),2]
    setTxtProgressBar(pb1,i)
    
  }
  
  name <- paste('SimLow', j, sep = '')
  assign(name, sim.matrix.low)
  name <- paste('SimMed', j, sep = '')
  assign(name, sim.matrix.med)
  name <- paste('SimHigh', j, sep = '')
  assign(name, sim.matrix.high)
  name <- paste('SimVhigh', j, sep = '')
  assign(name, sim.matrix.vhigh)
  
}

#make into dataframes
low5 <- data.frame(SimLow5);low10 <- data.frame(SimLow10);low50 <- data.frame(SimLow50);low100 <- data.frame(SimLow100) 
med5 <- data.frame(SimMed5);med10 <- data.frame(SimMed10);med50 <- data.frame(SimMed50);med100 <- data.frame(SimMed100)  
high5 <- data.frame(SimHigh5);high10 <- data.frame(SimHigh10);high50 <- data.frame(SimHigh50);high100 <- data.frame(SimHigh100)    
vhigh5 <- data.frame(SimVhigh5);vhigh10 <- data.frame(SimVhigh10);vhigh50 <- data.frame(SimVhigh50);vhigh100 <- data.frame(SimVhigh100) 

#add proper names and a time variable as well
prefix <- 'Sim'
suffix <- seq(1:10)

names <- paste(prefix, suffix, sep = '')
colnames(low5) <- names;colnames(low10) <- names;colnames(low50) <- names;colnames(low100) <- names
colnames(med5) <- names;colnames(med10) <- names;colnames(med50) <- names;colnames(med100) <- names
colnames(high5) <- names;colnames(high10) <- names;colnames(high50) <- names;colnames(high100) <- names
colnames(vhigh5) <- names;colnames(vhigh10) <- names;colnames(vhigh50) <- names;colnames(vhigh100) <- names


time <- data.frame(time = seq(1:100))

low5 <- cbind(time, low5);low10 <- cbind(time, low10);low50 <- cbind(time, low50);low100 <- cbind(time, low100)
med5 <- cbind(time, med5);med10 <- cbind(time, med10);med50 <- cbind(time, med50);med100 <- cbind(time, med100) 
high5 <- cbind(time, high5);high10 <- cbind(time, high10);high50 <- cbind(time, high50);high100 <- cbind(time, high100) 
vhigh5 <- cbind(time, vhigh5);vhigh10 <- cbind(time, vhigh10);vhigh50 <- cbind(time, vhigh50);vhigh100 <- cbind(time, vhigh100) 

#make a function to plot it all at once in ggplot
plotall <- function(df1, df2, df3, df4, level) { #call all necessary dataframes
  #figure out how many pops went extinct
  df1row <- df1[100,]
  count1 = 0
  for (i in df1row) {
    if(i == 0){
      count1 = count1 + 1
    }
  }
  df2row <- df2[100,]
  count2 = 0
  for (i in df2row) {
    if(i == 0){
      count2 = count2 + 1
    }
  }
  df3row <- df3[100,]
  count3 = 0
  for (i in df3row) {
    if(i == 0){
      count3 = count3 + 1
    }
  }
  df4row <- df4[100,]
  count4 = 0
  for (i in df4row) {
    if(i == 0){
      count4 = count4 + 1
    }
  }
  #make the labels of how many pop'ns went extinct
  label1 = paste('Starting Population \n Abundance =', level, sep = ' ')
  a = "Pop'ns ext:"
  label2 = paste(a, count1, sep = '');label3 = paste(a, count2, sep = '')
  label4 = paste(a, count3, sep = '');label5 = paste(a, count4, sep = '')
  
  
  
  stoch.plot <- ggplot(data = df1,aes(df1[,1])) + theme1() + #make initial plot
    labs(x = 'Time (Days)', y = 'Population Abundance', title = 'Stochastic Simulations for Increasing Concentrations') +
    annotate('text', x = 5, y = 4500, label = label1, size = 3.5, colour = 'black') +
    annotate('text', x = 3, y = 4000, label = label2, size = 3.5, colour = 'green4')+
    annotate('text', x = 3, y = 2900, label = label3, size = 3.5, colour = 'blue3')+
    annotate('text', x = 3, y = 1900, label = label4, size = 3.5, colour = 'orange3')+
    annotate('text', x = 3, y = 1000, label = label5, size = 3.5, colour = 'red4')
  for (i in names(df1)[-1]){ #add each grouping as necessary, specifying the dataframe
    stoch.plot <- stoch.plot + geom_line(aes_string(y=i), colour = 'green4', size =0.01) 
  }
  for (i in names(df2)[-1]){ #must specify data argument if not the df that was used to make original plot
    stoch.plot <- stoch.plot + geom_line(data = df2, aes_string(y=i), colour = 'blue3', size =0.01)
  }
  for (i in names(df3)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df3, aes_string(y=i), colour = 'orange3', size =0.01)
  }
  for (i in names(df4)[-1]){
    stoch.plot <- stoch.plot + geom_line(data = df4, aes_string(y=i), colour = 'red4', size =0.01)
  }
  return(stoch.plot)
}

#make plot
stoch.plot5 <- plotall1(low5, med5, high5, vhigh5, 5)
stoch.plot10 <- plotall2(low10, med10, high10, vhigh10, 10)
stoch.plot50 <- plotall3(low50, med50, high50, vhigh50, 50)
stoch.plot100 <- plotall4(low100, med100, high100, vhigh100, 100)

stoch.plots.2100 <- plot_grid(stoch.plot5, stoch.plot10, stoch.plot50, stoch.plot100, nrow = 2, ncol = 2, 
                             rel_widths = c(1,1,1,1), rel_heights = c(0.7, 0.7, 0.7, 0.7), hjust = c(-6,-4, -6,-4), 
                             labels = c('A', 'B', 'C', 'D'))
stoch.plots.2100

########################## Distribution to pull the plastic data from
## so how  we're going to do this is by scaling all of Kennedy's concentrations to what we want

meta_data = read.csv('C:/Users/coleb/Dropbox/Daphnia Model/kennedy_data.csv')

meta_data = meta_data %>% 
  mutate(cur_mesh = 26.412*(`^`(mesh_mm*1000,-1.743))) %>% #use the power function to figure out the effect from mesh size
  mutate(scale_factor = mesh0.190um/cur_mesh) %>% #get the scaling factor
  mutate(scaled_conc = Conc_ml * scale_factor) %>% #multiply by the scaling factor
  mutate(conc_2050 = scaled_conc * future_production_ratio[1]) %>% 
  mutate(conc_2100 = scaled_conc * future_production_ratio[2])

dist_curr = rnorm(n=10000, mean = ((current[3]-current[1])/2), sd = (((current[3]-current[1])/2)/3))
dist_2050 = rnorm(n=10000, mean = ((future_concentrations2050[3]-future_concentrations2050[1])/2), 
                  sd = (((future_concentrations2050[3]-future_concentrations2050[1])/2)/3))
dist_2100 = rnorm(n=10000, mean = ((future_concentrations2100[3]-future_concentrations2100[1])/2), 
                  sd = (((future_concentrations2100[3]-future_concentrations2100[1])/2)/3))
hist(dist_2100)





######### DIDN'T USE THE BELOW CODE
#let's add in bins that correspond to the bins kennedy used but let's make them spaced by Order Mag between min and max
#NOTE: here we excluded the max value from the data since we recognize that we're using a power function and there's problems 
#with that, so we think ~200,000 is probably not very realistic
# bins_scaled = matrix(nrow = 80, ncol = 1)
# for(row1 in 1:nrow(meta_data)) {
#   row = meta_data[row1,]
#   if(row$scaled_conc <= 1e-04) {
#     bins_scaled[row1,] = 1
#   } else if (row$scaled_conc > 1e-04 & row$scaled_conc <= 1e-03) {
#     bins_scaled[row1,] = 2
#   } else if (row$scaled_conc > 1e-03 & row$scaled_conc <= 1e-02) {
#     bins_scaled[row1,] = 3
#   } else if (row$scaled_conc > 1e-02 & row$scaled_conc <= 1e-01) {
#     bins_scaled[row1,] = 4
#   } else if (row$scaled_conc > 1e-01 & row$scaled_conc <= 1) {
#     bins_scaled[row1,] = 5
#   } else if (row$scaled_conc > 1 & row$scaled_conc <= 1e+1) {
#     bins_scaled[row1,] = 6
#   } else if (row$scaled_conc > 1e+1 & row$scaled_conc <= 1e+2) {
#     bins_scaled[row1,] = 7
#   } else if (row$scaled_conc > 1e+2 & row$scaled_conc <= 1e+3) {
#     bins_scaled[row1,] = 8
#   } else if (row$scaled_conc > 1e+3 & row$scaled_conc <= 1e+4) {
#     bins_scaled[row1,] = 9
#   } else if (row$scaled_conc > 1e+4 & row$scaled_conc <= 1e+5) {
#     bins_scaled[row1,] = 10
#   }
#   
# }
# 
# hist(bins_scaled)
# 
# meta_data$bins_scaled = bins_scaled
# 
# meta_data %>% #figure out how many observations are in each bin, then 
#   filter(bins_scaled == 10) %>% 
#   count()
# x = 10000/79
# bin01 = runif(round(x*1), 0, 1e-4)
# bin02 = runif(round(x*0), 1.0001e-4, 1e-3)
# bin03 = runif(round(x*1), 1.0001e-3, 1e-2)
# bin04 = runif(round(x*4), 1.0001e-2, 1e-1)
# bin05 = runif(round(x*20), 0.10000001, 1)
# bin06 = runif(round(x*21), 1.0001, 1e+1)
# bin07 = runif(round(x*15), 1.0001e+1, 1e+2)
# bin08= runif(round(x*10), 1.0001e+2, 1e+3)
# bin09 = runif(round(x*4), 1.0001e+3, 1e+4)
# bin10= runif(round(x*3), 1.0001e+4, 1e+5)
# 
# dist_curr = c(bin01,bin02,bin03,bin04,bin05,bin06,bin07,bin08,bin09,bin10)
# dist_2050 = dist_curr*future_production_ratio[1]
# dist_2100 = dist_curr*future_production_ratio[2]

### so now let's run a series of simulations for now, 2050 and 2100 to see what happens

#### current levels

pb1 = txtProgressBar(min = 0, max = 1000, initial = 0, char = ".Don't Touch, Running..", style = 1, width = 20)

#make the matricies
sim.matrix.curr <- matrix(nrow = 100,ncol = 1000) #change ncol with number of sims


#run the sim
N0s <- c(50)
for (j in N0s) {
  
  x0 <- c(N = j)
  pa = sample(dist_curr, 1000, replace = TRUE) #change 2nd argument with number of sims


  for (i in 1:1000) { #change second number with number of sims
    
    #make the phi and alpha parameters
    phi_curr <- as.numeric(lapply(pa[i], EC50fun))
    alpha_curr <- as.numeric(lapply(pa[i], LC50fun))
    
    #make the individual propensity function
    a <- c("(b-phi)*N*(1-(N/k))", "(u+alpha)*N")
    #make state change matrix
    nu <- matrix(c(+1,-1), ncol = 2)
    #time units
    tf = 175
    #method
    method <- "OTL"
    #sim name
    simName <- "daphgrow"
    
    #low
    parms1 <- c(b=pcbr, phi=phi_curr, k=5000, u=pcdr, alpha=alpha_curr) #set parameters
    sim_dist_curr <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, censusInterval = 1)) #run simulation
    temp.curr <- sim_dist_curr$data #take just the data part of the simulation and put it in a new variable
    rows <- length(temp.curr)/2 #determine the length of the new variable 
    if (rows < 100) { #this s for simulations that go to zero and stop, so we can keep in the 'zeros'
      temp <- matrix(nrow = (100-rows), ncol = 2) #make a matrix of the size to make up the difference between where sim stopped and 100
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100)) #fill it with the time stamps and 0s
      temp.curr <- rbind(temp.curr, temp) #bind them so you have a matrix with 100 rows
    }
    sim.matrix.curr[,i] <- temp.curr[c(1:100),2] #bind the results part of the matrix to the overall sim results

    setTxtProgressBar(pb1,i)
    
  }
  
}

SimDistCurr <- data.frame(sim.matrix.curr) 

prefix <- 'Sim'
suffix <- seq(1:1000) #change second number with number of sims

names <- paste(prefix, suffix, sep = '')
colnames(SimDistCurr) <- names

time <- data.frame(time = seq(1:100))

SimDistCurr <- cbind(time, SimDistCurr)

plotall_distCurr <- function(df1, level) { #call dataframe and starting abundance
  #figure out how many pops went extinct
  df1row <- df1[100,]
  count1 = 0
  for (i in df1row) {
    if(i == 0){
      count1 = count1 + 1
    }
  }
  #make the labels of how many pop'ns went extinct
  label1 = paste('Starting Population \n Abundance =', level, sep = ' ')
  a = "Pop'ns ext:"
  label2 = paste(a, count1, sep = '')
  
  
  stoch.plot <- ggplot(data = df1,aes(df1[,1])) + theme1() + #make initial plot
    labs(x = '', y = 'Population Abundance', title = 'Current Concentrations') +
    annotate('text', x = 10, y = 5050, label = label2, size = 5.0, colour = 'black')
  for (i in names(df1)[-1]){ #add each grouping as necessary, specifying the dataframe
    stoch.plot <- stoch.plot + geom_line(aes_string(y=i), colour = 'blue4', size =0.01) 
  }
  return(stoch.plot)
}
plotall_dist2050 <- function(df1, level) { #call dataframe and starting abundance
  #figure out how many pops went extinct
  df1row <- df1[100,]
  count1 = 0
  for (i in df1row) {
    if(i == 0){
      count1 = count1 + 1
    }
  }
  #make the labels of how many pop'ns went extinct
  label1 = paste('Starting Population \n Abundance =', level, sep = ' ')
  a = "Pop'ns ext:"
  label2 = paste(a, count1, sep = '')
  
  
  stoch.plot <- ggplot(data = df1,aes(df1[,1])) + theme1() + #make initial plot
    labs(x = '', y = 'Population Abundance', title = '2050 Concentrations') +
    annotate('text', x = 10, y = 5050, label = label2, size = 5.0, colour = 'black') 
  for (i in names(df1)[-1]){ #add each grouping as necessary, specifying the dataframe
    stoch.plot <- stoch.plot + geom_line(aes_string(y=i), colour = 'blue4', size =0.01) 
  }
  return(stoch.plot)
}
plotall_dist2100 <- function(df1, level) { #call dataframe and starting abundance
  #figure out how many pops went extinct
  df1row <- df1[100,]
  count1 = 0
  for (i in df1row) {
    if(i == 0){
      count1 = count1 + 1
    }
  }
  #make the labels of how many pop'ns went extinct
  label1 = paste('Starting Population \n Abundance =', level, sep = ' ')
  a = "Pop'ns ext:"
  label2 = paste(a, count1, sep = '')
  
  
  stoch.plot <- ggplot(data = df1,aes(df1[,1])) + theme1() + #make initial plot
    labs(x = 'Day', y = 'Population Abundance', title = '2100 Concentrations') +
    annotate('text', x = 10, y = 5050, label = label2, size = 5.0, colour = 'black') 
  for (i in names(df1)[-1]){ #add each grouping as necessary, specifying the dataframe
    stoch.plot <- stoch.plot + geom_line(aes_string(y=i), colour = 'blue4', size =0.01) 
  }
  return(stoch.plot)
}

#make plot
stoch_dist_plot_curr <- plotall_distCurr(SimDistCurr, 50)


#### 2050 levels

pb1 = txtProgressBar(min = 0, max = 1000, initial = 0, char = ".Don't Touch, Running..", style = 1, width = 20)

#make the matricies
sim.matrix.2050 <- matrix(nrow = 100,ncol = 1000) #change ncol with number of sims

#run the sim
N0s <- c(50)
for (j in N0s) {
  
  x0 <- c(N = j)
  pa = sample(dist_2050, 1000, replace = TRUE) #change 2nd argument with number of sims
  
  
  for (i in 1:1000) { #change second number with number of sims
    
    #make the phi and alpha parameters
    phi_2050 <- as.numeric(lapply(pa[i], EC50fun))
    alpha_2050 <- as.numeric(lapply(pa[i], LC50fun))
    
    #make the individual propensity function
    a <- c("(b-phi)*N*(1-(N/k))", "(u+alpha)*N")
    #make state change matrix
    nu <- matrix(c(+1,-1), ncol = 2)
    #time units
    tf = 175
    #method
    method <- "OTL"
    #sim name
    simName <- "daphgrow"
    
    #low
    parms1 <- c(b=pcbr, phi=phi_2050, k=5000, u=pcdr, alpha=alpha_2050) #set parameters
    sim_dist_2050 <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                          verbose = FALSE, censusInterval = 1)) #run simulation
    temp.2050 <- sim_dist_2050$data #take just the data part of the simulation and put it in a new variable
    rows <- length(temp.2050)/2 #determine the length of the new variable 
    if (rows < 100) { #this s for simulations that go to zero and stop, so we can keep in the 'zeros'
      temp <- matrix(nrow = (100-rows), ncol = 2) #make a matrix of the size to make up the difference between where sim stopped and 100
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100)) #fill it with the time stamps and 0s
      temp.2050 <- rbind(temp.2050, temp) #bind them so you have a matrix with 100 rows
    }
    sim.matrix.2050[,i] <- temp.2050[c(1:100),2] #bind the results part of the matrix to the overall sim results
    
    setTxtProgressBar(pb1,i)
    
  }
  
}

SimDist2050 <- data.frame(sim.matrix.2050)

prefix <- 'Sim'
suffix <- seq(1:1000) #change with number of sims

names <- paste(prefix, suffix, sep = '')
colnames(SimDist2050) <- names

time <- data.frame(time = seq(1:100))

SimDist2050 <- cbind(time, SimDist2050)

#make plot
stoch_dist_plot_2050 <- plotall_dist2050(SimDist2050, 50)


#### 2100 levels

pb1 = txtProgressBar(min = 0, max = 1000, initial = 0, char = ".Don't Fucking Touch Me, I'm Running A Simulation..", style = 1, width = 20)

#make the matricies
sim.matrix.2100 <- matrix(nrow = 100,ncol = 1000) #change with sim

#run the sim
N0s <- c(50)
for (j in N0s) {
  
  x0 <- c(N = j)
  pa = sample(dist_2100, 1000, replace = TRUE) #change 2nd argument with number of sims
  
  
  for (i in 1:1000) { #change second number with number of sims
    
    #make the phi and alpha parameters
    phi_2100 <- as.numeric(lapply(pa[i], EC50fun))
    alpha_2100 <- as.numeric(lapply(pa[i], LC50fun))
    
    #make the individual propensity function
    a <- c("(b-phi)*N*(1-(N/k))", "(u+alpha)*N")
    #make state change matrix
    nu <- matrix(c(+1,-1), ncol = 2)
    #time units
    tf = 175
    #method
    method <- "OTL"
    #sim name
    simName <- "daphgrow"
    
    #low
    parms1 <- c(b=pcbr, phi=phi_2100, k=5000, u=pcdr, alpha=alpha_2100) #set parameters
    sim_dist_2100 <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                          verbose = FALSE, censusInterval = 1)) #run simulation
    temp.2100 <- sim_dist_2100$data #take just the data part of the simulation and put it in a new variable
    rows <- length(temp.2100)/2 #determine the length of the new variable 
    if (rows < 100) { #this s for simulations that go to zero and stop, so we can keep in the 'zeros'
      temp <- matrix(nrow = (100-rows), ncol = 2) #make a matrix of the size to make up the difference between where sim stopped and 100
      temp[,2] <- 0; temp[,1] <- c(seq((100-(99-rows)), 100)) #fill it with the time stamps and 0s
      temp.2100 <- rbind(temp.2100, temp) #bind them so you have a matrix with 100 rows
    }
    sim.matrix.2100[,i] <- temp.2100[c(1:100),2] #bind the results part of the matrix to the overall sim results
    
    setTxtProgressBar(pb1,i)
    
  }
  
}
SimDist2100 <- data.frame(sim.matrix.2100)

prefix <- 'Sim'
suffix <- seq(1:1000)

names <- paste(prefix, suffix, sep = '')
colnames(SimDist2100) <- names

time <- data.frame(time = seq(1:100))

SimDist2100 <- cbind(time, SimDist2100)

#make plot
stoch_dist_plot_2100 <- plotall_dist2100(SimDist2100, 50)


############## Combine some plots for easier viewing
detplot = plot_grid(deterministic_current_plot, deterministic_2050_plot, deterministic_2100_plot, 
                    nrow = 3, labels = c('A', 'B', 'C'))
stochplot = plot_grid(stoch_dist_plot_curr, stoch_dist_plot_2050, stoch_dist_plot_2100, 
                      nrow = 3, labels = c('A', 'B', 'C')) #export 736x1800




############## This one is the heat map for loop

sim.matrix.heat <- matrix(nrow = 100,ncol = 100)

#starting conditions
N0 <- 50
#set amount of time steps to run in simulation
TT <- seq(1,100,1)
#give parameters
k <- 5000
b <- 0.26
u <- 0.03

rev_seq <- seq(100, 1, -1)

for(i in 1:100) { #this part is for phi
  
  for(j in 1:100) {     #this part is for alpha
    q <- rev_seq[i]
    #specify changing variables
    phi = phi100exp[i]; alpha = alpha100exp[j]
    parms <- c(b,phi,k,u,alpha)
    
    #run lsoda, which is an ODE solver in the deSolve package, and save the results into an object
    sim.results.heat <- lsoda(N0, TT, daphgrow, parms)
    
    sim.matrix.heat[q,j] <- sim.results.heat[100,2] 
    
    #and then run your simulation so 'results = your function with the changing variables here
  }
}

#now make it in a heatmap
hm_col <- colorRampPalette(c("black","blue","green","orange","red"))(100000)
heat <- image(matrix.heat, 
      col = hm_col)
matrix.heat <- sim.matrix.heat

for (i in 100){
  for (j in 100){
    if(matrix.heat[i,j] > 50){
      matrix.heat[i,j] <- 10
      
    }
    # if(matrix.heat[i,j] <3000){
    #   matrix.heat[i,j] = 9
    # }
    # if(matrix.heat[i,j] <500){
    #   matrix.heat[i,j] = 8
    # }
    if(matrix.heat[i,j] <50){
      matrix.heat[i,j] <- 1
    }
  }
}

########thought: what if we ran the simulations again but with a secondary stressor to see when population
#declines

###### Next: use the min mean and max to create some sort of distribution with plastic concentrations
# and then simulation using random samples from that distribution at the three different
# time periods - I think that could work very well 



############### all of the data to make the geom for the future plastic stuff
years <- c(1950,
           1951,
           1952,
           1953,
           1954,
           1955,
           1956,
           1957,
           1958,
           1959,
           1960,
           1961,
           1962,
           1963,
           1964,
           1965,
           1966,
           1967,
           1968,
           1969,
           1970,
           1971,
           1972,
           1973,
           1974,
           1975,
           1976,
           1977,
           1978,
           1979,
           1980,
           1981,
           1982,
           1983,
           1984,
           1985,
           1986,
           1987,
           1988,
           1989,
           1990,
           1991,
           1992,
           1993,
           1994,
           1995,
           1996,
           1997,
           1998,
           1999,
           2000,
           2001,
           2002,
           2003,
           2004,
           2005,
           2006,
           2007,
           2008,
           2009,
           2010,
           2011,
           2012,
           2013,
           2014,
           2015)

plastic <- c(2,
             2,
             2,
             3,
             3,
             4,
             5,
             5,
             6,
             7,
             8,
             9,
             11,
             13,
             15,
             17,
             20,
             23,
             27,
             32,
             35,
             38,
             44,
             51,
             52,
             46,
             54,
             59,
             64,
             71,
             70,
             72,
             73,
             80,
             86,
             90,
             96,
             104,
             110,
             114,
             120,
             124,
             132,
             137,
             151,
             156,
             168,
             180,
             188,
             202,
             213,
             218,
             231,
             241,
             256,
             263,
             280,
             295,
             281,
             288,
             313,
             325,
             338,
             352,
             367,
             381)


years1 <- c(1950, 1960, 1970, 1980, 1990, 2000, 2010)
prod <- c(0, 8, 22, 50, 88, 170, 270)

# #run for loop doing the desolve 
# #specify the changing values and run the forloop with the three conditions (low, med, high)
# alphas <- c(alpha100exp[1], alpha100exp[24], alpha100exp[31])
# phis <- c(phi100exp[1], phi100exp[24], phi100exp[31])
# 
# 
# 
# #set a progress bar for the interior sim
# pb1 = txtProgressBar(min = 0, max = 100, initial = 0, char = ".Please Don't Touch Me I'm Running..", style = 1, width = 20)
# 
# #run for the low, high and medium concentrations
# 
# system.time(for(j in 1:3) {
#   counter = j
#   #starting conditions
#   x0 <- c(N = 50)
#   #make the individual propensity function
#   a <- c("(b-(b*phi))*N*(1-(N/k))", "(u+alpha)*N")
#   #make state change matrix
#   nu <- matrix(c(+1,-1), ncol = 2)
#   #give parameters
#   alpha <- alphas[i]
#   phi <- phis[i] 
#   k <- 5000
#   b <- 0.26
#   u <- 0.03
#   parms <- c(b=0.26, phi=0.041296, k=5000, u=0.03, alpha=-0.0008429782)
#   #time units
#   tf = 125
#   #method
#   method <- "OTL"
#   #sim name
#   simName <- "daphgrow"
#   
#   stoch.matrix <- matrix(nrow = 100,ncol = 100)
#   
#   
#   for(i in 1:100) {
#     #run 
#     sim.results.low <- ssa(x0, a, nu, parms, tf, method, simName,
#                            verbose = FALSE, censusInterval = 1)
#     temp = sim.results.low$data
#     stoch.matrix[,i] <- temp[seq(1, 100), 1] #add the results to the matrix one by one
#     setTxtProgressBar(pb1,i)
#   }
# 
#   if (counter == 1) {
#   stoch.matrix.low <- data.frame(stoch.matrix)
# } else if (counter == 2) {
#   stoch.matrix.med <- data.frame(stoch.matrix)
#   } else {
#   stoch.matrix.high <- data.frame(stoch.matrix)
#   }
# 
# })
# 
# length(temp)




min = min(pollution_real_current)
max = max(pollution_real_current)
